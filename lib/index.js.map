{"version":3,"sources":["../src/index.ts","../src/roman-numerals/types.ts","../src/roman-numerals/validation.ts","../src/roman-numerals/domain/roman-converter.ts"],"sourcesContent":["export { romanToNumber } from \"./roman-numerals/domain/roman-converter\";\n","export class InvalidRomanNumeralError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"InvalidRomanNumeralError\";\n  }\n}\n","import { InvalidRomanNumeralError } from \"./types\";\n\nexport function validateRomanNumeral(input: string): void {\n  if (input === \"\") {\n    throw new InvalidRomanNumeralError(\"Empty string is not a valid Roman numeral\");\n  }\n\n  const validChars = new Set([\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"]);\n\n  for (const char of input) {\n    if (!validChars.has(char)) {\n      throw new InvalidRomanNumeralError(`Invalid character '${char}' in Roman numeral`);\n    }\n  }\n\n  validateConsecutiveSymbols(input);\n  validateNonRepeatableSymbols(input);\n}\n\nfunction validateConsecutiveSymbols(input: string): void {\n  let consecutiveCount = 1;\n  let previousChar = input[0];\n\n  for (let i = 1; i < input.length; i++) {\n    if (input[i] === previousChar) {\n      consecutiveCount++;\n      if (consecutiveCount >= 4) {\n        throw new InvalidRomanNumeralError(\n          `More than 3 consecutive '${previousChar}' symbols are not allowed`,\n        );\n      }\n    } else {\n      consecutiveCount = 1;\n      previousChar = input[i];\n    }\n  }\n}\n\nfunction validateNonRepeatableSymbols(input: string): void {\n  const nonRepeatableSymbols = [\"V\", \"L\", \"D\"];\n  const symbolCounts = new Map<string, number>();\n\n  for (const char of input) {\n    symbolCounts.set(char, (symbolCounts.get(char) || 0) + 1);\n  }\n\n  for (const symbol of nonRepeatableSymbols) {\n    const count = symbolCounts.get(symbol) || 0;\n    if (count > 1) {\n      throw new InvalidRomanNumeralError(`Symbol '${symbol}' cannot be repeated`);\n    }\n  }\n}\n","import { validateRomanNumeral } from \"../validation\";\nimport { InvalidRomanNumeralError } from \"../types\";\n\nexport function romanToNumber(input: string): number {\n  const normalizedInput = input.toUpperCase();\n  validateRomanNumeral(normalizedInput);\n\n  const subtractivePatterns = new Map<string, number>([\n    [\"IV\", 4],\n    [\"IX\", 9],\n    [\"XL\", 40],\n    [\"XC\", 90],\n    [\"CD\", 400],\n    [\"CM\", 900],\n  ]);\n\n  const symbolValues = new Map<string, number>([\n    [\"I\", 1],\n    [\"V\", 5],\n    [\"X\", 10],\n    [\"L\", 50],\n    [\"C\", 100],\n    [\"D\", 500],\n    [\"M\", 1000],\n  ]);\n\n  let total = 0;\n  let i = 0;\n\n  while (i < normalizedInput.length) {\n    // Check for 2-character subtractive patterns first\n    if (i < normalizedInput.length - 1) {\n      const twoChar = normalizedInput.substring(i, i + 2);\n      const subtractiveValue = subtractivePatterns.get(twoChar);\n\n      if (subtractiveValue !== undefined) {\n        total += subtractiveValue;\n        i += 2;\n        continue;\n      }\n    }\n\n    // If no subtractive pattern, process single character\n    const currentValue = symbolValues.get(normalizedInput[i]);\n\n    if (currentValue === undefined) {\n      throw new InvalidRomanNumeralError(`Invalid Roman numeral character: ${normalizedInput[i]}`);\n    }\n\n    total += currentValue;\n    i++;\n  }\n\n  return total;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAO,IAAM,2BAAN,cAAuC,MAAM;AAAA,EAClD,YAAY,SAAiB;AAC3B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EACd;AACF;;;ACHO,SAAS,qBAAqB,OAAqB;AACxD,MAAI,UAAU,IAAI;AAChB,UAAM,IAAI,yBAAyB,2CAA2C;AAAA,EAChF;AAEA,QAAM,aAAa,oBAAI,IAAI,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,GAAG,CAAC;AAE9D,aAAW,QAAQ,OAAO;AACxB,QAAI,CAAC,WAAW,IAAI,IAAI,GAAG;AACzB,YAAM,IAAI,yBAAyB,sBAAsB,IAAI,oBAAoB;AAAA,IACnF;AAAA,EACF;AAEA,6BAA2B,KAAK;AAChC,+BAA6B,KAAK;AACpC;AAEA,SAAS,2BAA2B,OAAqB;AACvD,MAAI,mBAAmB;AACvB,MAAI,eAAe,MAAM,CAAC;AAE1B,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,QAAI,MAAM,CAAC,MAAM,cAAc;AAC7B;AACA,UAAI,oBAAoB,GAAG;AACzB,cAAM,IAAI;AAAA,UACR,4BAA4B,YAAY;AAAA,QAC1C;AAAA,MACF;AAAA,IACF,OAAO;AACL,yBAAmB;AACnB,qBAAe,MAAM,CAAC;AAAA,IACxB;AAAA,EACF;AACF;AAEA,SAAS,6BAA6B,OAAqB;AACzD,QAAM,uBAAuB,CAAC,KAAK,KAAK,GAAG;AAC3C,QAAM,eAAe,oBAAI,IAAoB;AAE7C,aAAW,QAAQ,OAAO;AACxB,iBAAa,IAAI,OAAO,aAAa,IAAI,IAAI,KAAK,KAAK,CAAC;AAAA,EAC1D;AAEA,aAAW,UAAU,sBAAsB;AACzC,UAAM,QAAQ,aAAa,IAAI,MAAM,KAAK;AAC1C,QAAI,QAAQ,GAAG;AACb,YAAM,IAAI,yBAAyB,WAAW,MAAM,sBAAsB;AAAA,IAC5E;AAAA,EACF;AACF;;;ACjDO,SAAS,cAAc,OAAuB;AACnD,QAAM,kBAAkB,MAAM,YAAY;AAC1C,uBAAqB,eAAe;AAEpC,QAAM,sBAAsB,oBAAI,IAAoB;AAAA,IAClD,CAAC,MAAM,CAAC;AAAA,IACR,CAAC,MAAM,CAAC;AAAA,IACR,CAAC,MAAM,EAAE;AAAA,IACT,CAAC,MAAM,EAAE;AAAA,IACT,CAAC,MAAM,GAAG;AAAA,IACV,CAAC,MAAM,GAAG;AAAA,EACZ,CAAC;AAED,QAAM,eAAe,oBAAI,IAAoB;AAAA,IAC3C,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,CAAC;AAAA,IACP,CAAC,KAAK,EAAE;AAAA,IACR,CAAC,KAAK,EAAE;AAAA,IACR,CAAC,KAAK,GAAG;AAAA,IACT,CAAC,KAAK,GAAG;AAAA,IACT,CAAC,KAAK,GAAI;AAAA,EACZ,CAAC;AAED,MAAI,QAAQ;AACZ,MAAI,IAAI;AAER,SAAO,IAAI,gBAAgB,QAAQ;AAEjC,QAAI,IAAI,gBAAgB,SAAS,GAAG;AAClC,YAAM,UAAU,gBAAgB,UAAU,GAAG,IAAI,CAAC;AAClD,YAAM,mBAAmB,oBAAoB,IAAI,OAAO;AAExD,UAAI,qBAAqB,QAAW;AAClC,iBAAS;AACT,aAAK;AACL;AAAA,MACF;AAAA,IACF;AAGA,UAAM,eAAe,aAAa,IAAI,gBAAgB,CAAC,CAAC;AAExD,QAAI,iBAAiB,QAAW;AAC9B,YAAM,IAAI,yBAAyB,oCAAoC,gBAAgB,CAAC,CAAC,EAAE;AAAA,IAC7F;AAEA,aAAS;AACT;AAAA,EACF;AAEA,SAAO;AACT;","names":[]}